MODULE LinNet ["libc.so.7"];

	(*
		FreeBSD 11.0
		i386
	*)

	CONST
		NULL* = 0H;

		SOCKET_ERROR* = -1;
		INVALID_SOCKET* = -1;

		INADDR_NONE* = -1;
		INADDR_ANY* = 0;

		(* socket domains *)
			AF_UNSPEC* = 0; (* unspecified *)
			AF_UNIX* = 1; (* standardized name for AF_LOCAL *)
			AF_INET* = 2; (* internetwork: UDP, TCP, etc. *)
			AF_INET6* = 28; (* IPv6 *)

		(* socket types *)
			SOCK_STREAM* = 1; (* stream socket *)
			SOCK_DGRAM* = 2; (* datagram socket *)
			SOCK_RAW* = 3; (* raw-protocol interface *)
			SOCK_SEQPACKET* = 5; (* sequenced packet stream *)

		(* socket protocols *)
			IPPROTO_IP* = 0; (* dummy for IP *)
			IPPROTO_ICMP* = 1; (* control message protocol *)
			IPPROTO_TCP* = 6; (* tcp *)
			IPPROTO_UDP* = 17; (* user datagram protocol *)

		(* socket options *)
			SO_DEBUG* = {0}; (* turn on debugging info recording *)
			SO_ACCEPTCONN* = {1}; (* socket has had listen() *)
			SO_REUSEADDR* = {2}; (* allow local address reuse *)
			SO_KEEPALIVE* = {3}; (* keep connections alive *)
			SO_DONTROUTE* = {4}; (* just use interface addresses *)
			SO_BROADCAST* = {5}; (* permit sending of broadcast msgs *)
			SO_LINGER* = {7}; (* linger on close if data present *)
			SO_OOBINLINE* = {8}; (* leave received OOB data in line *)
			SO_NO_OFFLOAD* = {14}; (* socket cannot be offloaded *)
			SO_NO_DDP* = {15}; (* disable direct data placement *)
			SO_SNDBUF* = {0,12}; (* send buffer size *)
			SO_RCVBUF* = {1,12}; (* receive buffer size *)
			SO_SNDLOWAT* = {0,1,12}; (* send low-water mark *)
			SO_RCVLOWAT* = {2,12}; (* receive low-water mark *)
			SO_SNDTIMEO* = {0,2,12}; (* send timeout *)
			SO_RCVTIMEO* = {1,2,12}; (* receive timeout *)
			SO_ERROR* = {0..2,12}; (* get error status and clear *)
			SO_TYPE* = {3,12}; (* get socket type *)

		SHUT_RD* = 0; (* shut down the reading side *)
		SHUT_WR* = 1; (* shut down the writing side *)
		SHUT_RDWR* = 2; (* shut down both sides *)

		SOL_SOCKET* = 0FFFFH; (* {0..15} *) (* options for socket level *)

		MSG_OOB* = {0}; (* process out-of-band data *)
		MSG_PEEK* = {1}; (* peek at incoming message *)
		MSG_DONTROUTE* = {2}; (* send without using routing tables *)
		MSG_EOR* = {3}; (* data completes record *)
		MSG_TRUNC* = {4}; (* data discarded before delivery *)
		MSG_CTRUNC* = {5}; (* control data lost before delivery *)
		MSG_WAITALL* = {6}; (* wait for full request or error *)

		SOMAXCONN* = 128;

		(* addrinfo.ai_flags *)
			AI_PASSIVE* = {0}; (* get address to use bind() *)
			AI_CANONNAME* = {1}; (* fill ai_canonname *)
			AI_NUMERICHOST* = {2}; (* prevent host name resolution *)
			AI_NUMERICSERV* = {3}; (* prevent service name resolution *)
			AI_ALL* = {8}; (* IPv6 and IPv4-mapped (with AI_V4MAPPED) *)
			AI_V4MAPPED_CFG* = {9}; (* accept IPv4-mapped if kernel supports *)
			AI_ADDRCONFIG* = {10}; (* only if any address is assigned *)
			AI_V4MAPPED* = {11}; (* accept IPv4-mapped IPv6 address *)

		(* getaddrinfo/getnameinfo/gai_strerror error codes *)
			EAI_AGAIN* = 2; (* temporary failure in name resolution *)
			EAI_BADFLAGS* = 3; (* invalid value for ai_flags *)
			EAI_FAIL* = 4; (* non-recoverable failure in name resolution *)
			EAI_FAMILY* = 5; (* ai_family not supported *)
			EAI_MEMORY* = 6; (* memory allocation failure *)
			EAI_NONAME* = 8; (* hostname nor servname provided, or not known *)
			EAI_SERVICE* = 9; (* servname not supported for ai_socktype *)
			EAI_SOCKTYPE* = 10; (* ai_socktype not supported *)
			EAI_SYSTEM* = 11; (* system error returned in errno *)
			EAI_BADHINTS* = 12; (* invalid value for hints *)
			EAI_PROTOCOL* = 13; (* resolved protocol is unknown *)
			EAI_OVERFLOW* = 14; (* argument buffer overflow *)
			EAI_MAX* = 15;

		(* FreeBSD 11.0 /usr/include/sys/select.h *)
			FD_SETSIZE = 1024;
			_NFDBITS = 8 * 4;

	TYPE
		u_int8_t = SHORTCHAR;
		int8_t = SHORTCHAR;
		uint16_t = SHORTINT;
		(* PtrVoid, int, intFlags, short, socklen_t, size_t, ssize_t, in_addr_t, in_port_t, time_t, suseconds_t, nfds_t, sa_family_t *)
		PtrVoid* = INTEGER;
		short* = SHORTINT;
		int* = INTEGER;
		intFlags* = SET;
		size_t* = INTEGER;
		ssize_t* = INTEGER;
		time_t* = INTEGER;
		suseconds_t* = INTEGER;
		socklen_t* = INTEGER;
		in_addr_t* = INTEGER;
		in_port_t* = SHORTINT;
		nfds_t* = INTEGER;
		sa_family_t* = SHORTCHAR;

		PtrSTR* = POINTER [untagged] TO ARRAY [untagged] OF SHORTCHAR;

		SOCKET* = int;

(*
		in_addr* = RECORD [untagged]
			s_addr*: in_addr_t;
		END;
*)
		in_addr* = RECORD [untagged]
			S_un*: RECORD [union]
				S_un_b*: RECORD [untagged]
					s_b1*: SHORTCHAR;
					s_b2*: SHORTCHAR;
					s_b3*: SHORTCHAR;
					s_b4*: SHORTCHAR;
				END;
				S_un_w*: RECORD [untagged]
					s_w1*: SHORTINT;
					s_w2*: SHORTINT;
				END;
				S_addr*: in_addr_t;
			END;
		END;

		Ptrsockaddr* = POINTER [untagged] TO sockaddr;
		sockaddr* = RECORD [untagged]
			(* FreeBSD 11.0 /usr/include/sys/socket.h *)
				sa_len*: SHORTCHAR; (* total length *)
				sa_family*: sa_family_t; (* address family *)
				sa_data*: ARRAY [untagged] 14 OF SHORTCHAR; (* actually longer; address value *)
		END;

		Ptrsockaddr_storage = POINTER [untagged] TO sockaddr_storage;
		sockaddr_storage* = RECORD [untagged]
			(* FreeBSD 11.0 /usr/include/sys/_sockaddr_storage.h *)
				ss_len*: SHORTCHAR; (* address length *)
				ss_family*: sa_family_t; (* address family *)
				__ss_pad1: ARRAY [untagged] 8 - 2 OF SHORTCHAR;
				__ss_align: LONGINT; (* force desired struct alignment *)
				__ss_pad2: ARRAY [untagged] 128 - 1 - 1 - (8 - 2) - 8 OF SHORTCHAR;
		END;

		Ptrsockaddr_in* = POINTER [untagged] TO sockaddr_in;
		sockaddr_in* = RECORD [untagged]
			(* FreeBSD 11.0 /usr/include/netinet/in.h *)
				sin_len*: SHORTCHAR;
				sin_family*: sa_family_t;
				sin_port*: in_port_t;
				sin_addr*: in_addr;
				sin_zero*: ARRAY [untagged] 8 OF SHORTCHAR;
		END;

		Ptraddrinfo* = POINTER [untagged] TO addrinfo;
		addrinfo* = RECORD [untagged]
			(* FreeBSD 11.0 /usr/include/netdb.h *)
				ai_flags*: intFlags;
				ai_family*: int;
				ai_socktype*: int;
				ai_protocol*: int;
				ai_addrlen*: socklen_t;
				ai_canonname*: PtrSTR;
				ai_addr*: Ptrsockaddr;
				ai_next*: Ptraddrinfo;
		END;

		timeval* = RECORD [untagged]
			(* Linux, FreeBSD, OpenBSD *)
				tv_sec*: time_t; (* seconds *)
				tv_usec*: suseconds_t; (* and microseconds *)
		END;

		pollfd* = RECORD [untagged]
			(* Linux, FreeBSD, OpenBSD *)
				fd*: int;
				events*: short;
				revents*: short;
		END;

		(* FreeBSD 11.0 /usr/include/sys/select.h *)
			__fd_mask = SET;
			fd_set* = ARRAY [untagged] (FD_SETSIZE + (_NFDBITS - 1)) DIV _NFDBITS OF __fd_mask;

	(* POSIX.1 *)
		PROCEDURE [ccall] socket* (domain: int; type: int; protocol: int): SOCKET;
		PROCEDURE [ccall] accept* (s: SOCKET; VAR addr: sockaddr; VAR addrlen: socklen_t): SOCKET;
		PROCEDURE [ccall] bind* (s: SOCKET; VAR name: sockaddr; namelen: socklen_t): int;
		PROCEDURE [ccall] connect* (s: SOCKET; VAR name: sockaddr; namelen: socklen_t): int;
		PROCEDURE [ccall] getsockname* (s: SOCKET; VAR name: sockaddr; VAR namelen: socklen_t): int;
		PROCEDURE [ccall] listen* (s: SOCKET; backlog: int): int;
		PROCEDURE [ccall] recv* (s: SOCKET; buf: PtrVoid; len: size_t; flags: intFlags): ssize_t;
		PROCEDURE [ccall] send* (s: SOCKET; msg: PtrVoid; len: size_t; flags: intFlags): ssize_t;
		PROCEDURE [ccall] shutdown* (s: SOCKET; how: int): int;
		PROCEDURE [ccall] getsockopt* (s: SOCKET; level: int; optname: intFlags; optval: PtrVoid; VAR [nil] optlen: socklen_t): int;
		PROCEDURE [ccall] setsockopt* (s: SOCKET; level: int; optname: intFlags; optval: PtrVoid; optlen: socklen_t): int;

		PROCEDURE [ccall] inet_addr* (cp: PtrSTR): in_addr_t;
		PROCEDURE [ccall] htons* (host16: uint16_t): uint16_t;

		PROCEDURE [ccall] select* (nfds: INTEGER; VAR [nil] readfds: fd_set; VAR [nil] writefds: fd_set; VAR [nil] exceptfds: fd_set; VAR timeout: timeval): int;

		PROCEDURE [ccall] poll* (VAR fds: ARRAY [untagged] OF pollfd; nfds: nfds_t; timeout: int): int;

(*
	PROCEDURE FD_ZERO (VAR set: Net.fd_set);
		VAR i: INTEGER;
	BEGIN
		i := LEN(set); REPEAT DEC(i); set[i] := {} UNTIL i = 0
	END FD_ZERO;

	PROCEDURE FD_SET (fd: Net.SOCKET; VAR set: Net.fd_set);
	BEGIN
		INCL(set[fd DIV 32], fd MOD 32)
	END FD_SET;
*)

	(* POSIX.1g *)
		PROCEDURE [ccall] getaddrinfo* (hostname: PtrSTR; servname: PtrSTR; VAR [nil] hints: addrinfo; VAR res: Ptraddrinfo): int;
		PROCEDURE [ccall] freeaddrinfo* (ai: Ptraddrinfo);

		PROCEDURE [ccall] gai_strerror* (ecode: int): PtrSTR;

END LinNet.